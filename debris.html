<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Debris Celestial Chart</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      background: linear-gradient(to bottom, #0d1b2a, #1b263b);
      color: #ffffff;
      font-family: 'Avenir', 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    .app-container {
      width: 100%;
      min-height: 100vh;
      position: relative;
    }

    .starry-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .chart-container {
      width: 100%;
      max-width: 90vw;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      z-index: 2;
    }

    #chart {
      width: 100%;
      max-width: 1000px;
      aspect-ratio: 1/1;
      display: block;
      background: transparent;
    }

    .interval-segment {
      stroke: rgba(255, 255, 255, 0.9);
      stroke-width: 1px;
      transition: all 0.4s ease;
      filter: drop-shadow(0 0 4px rgba(69, 123, 157, 0.5));
      animation: fadeIn 1s ease-in;
    }

    .interval-segment:hover {
      fill-opacity: 0.85;
      filter: drop-shadow(0 0 8px rgba(69, 123, 157, 0.8));
      cursor: pointer;
    }

    .label {
      font-family: 'Avenir', 'Helvetica Neue', Arial, sans-serif;
      fill: #ffffff;
      font-size: 11px;
      text-anchor: middle;
      filter: drop-shadow(0 0 3px rgba(69, 123, 157, 0.9));
      font-weight: 400;
      letter-spacing: 0.5px;
      paint-order: stroke;
      stroke: rgba(29, 53, 87, 0.8);
      stroke-width: 1px;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .title {
      fill: #ffffff;
      font-size: 18px;
      text-anchor: middle;
      font-weight: 500;
      letter-spacing: 1.5px;
      filter: drop-shadow(0 0 3px rgba(69, 123, 157, 0.5));
    }

    .subtitle {
      fill: rgba(255, 255, 255, 0.8);
      font-size: 12px;
      text-anchor: middle;
      font-weight: 300;
      letter-spacing: 1px;
    }

    .celestial-circle {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 0.5px;
    }

    .celestial-circle-dashed {
      fill: none;
      stroke: rgba(255, 255, 255, 0.25);
      stroke-width: 0.7px;
      stroke-dasharray: 2, 4;
    }

    .celestial-circle-dotted {
      fill: none;
      stroke: rgba(255, 255, 255, 0.3);
      stroke-width: 0.5px;
      stroke-dasharray: 0.5, 3;
    }

    .radial-line {
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 0.5px;
    }

    .celestial-body {
      fill: #ffffff;
      filter: drop-shadow(0 0 4px rgba(69, 123, 157, 0.6));
    }

    .celestial-body-glow {
      fill: rgba(69, 123, 157, 0.4);
      filter: blur(3px);
    }

    .constellation-line {
      stroke: rgba(255, 255, 255, 0.3);
      stroke-width: 0.5px;
      stroke-dasharray: 2, 3;
    }

    .grid-dot {
      fill: rgba(255, 255, 255, 0.4);
    }

    .star {
      fill: #ffffff;
      filter: drop-shadow(0 0 2px rgba(69, 123, 157, 0.6));
    }

    .popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 20px;
      background: rgba(29, 53, 87, 0.85);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(69, 123, 157, 0.2);
      max-width: 300px;
      width: 90%;
      z-index: 1000;
      display: none;
      font-family: 'Avenir', 'Helvetica Neue', Arial, sans-serif;
      font-size: 12px;
      line-height: 1.5;
    }

    .popup h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 5px;
    }

    .popup p {
      margin: 5px 0;
      font-size: 11px;
    }

    .popup .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #ffffff;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
      display: none;
    }

    @media (max-width: 768px) {
      .chart-container {
        padding: 10px;
      }

      .title {
        font-size: 16px;
      }

      .subtitle {
        font-size: 10px;
      }

      .label {
        font-size: 9px;
        stroke-width: 0.5px;
      }

      .popup {
        font-size: 10px;
        max-width: 250px;
      }

      .popup h4 {
        font-size: 12px;
      }

      .popup p {
        font-size: 10px;
      }
    }
    
    @media (max-width: 480px) {
      .chart-container {
        padding: 5px;
      }

      .title {
        font-size: 14px;
      }

      .subtitle {
        font-size: 8px;
      }

      .label {
        font-size: 7px;
        stroke-width: 0.5px;
      }

      .popup {
        font-size: 9px;
        max-width: 200px;
      }

      .popup h4 {
        font-size: 11px;
      }

      .popup p {
        font-size: 9px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <svg class="starry-background"></svg>
    
    <div class="chart-container">
      <div class="popup-overlay"></div>
      <div class="popup">
        <button class="close-btn">×</button>
        <h4></h4>
        <p></p>
      </div>
      <svg id="chart"></svg>
    </div>
  </div>

  <script>
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
    function createResponsiveSVG() {
      const container = document.querySelector('.chart-container');
      const containerWidth = Math.min(window.innerWidth * 0.9, container.clientWidth);
      const containerHeight = Math.min(window.innerHeight * 0.9, container.clientHeight);
      
      const size = Math.min(containerWidth, containerHeight) * 1.1;
      
      const svg = d3.select('#chart')
        .attr('width', size)
        .attr('height', size)
        .attr('viewBox', `-${size/2} -${size/2} ${size} ${size}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
      
      return size;
    }
    const handleResize = debounce(() => {
      const newSize = createResponsiveSVG();
      renderChart(window.chartData || mockData);
      updateStarryBackground();
    }, 100);
    window.addEventListener('resize', handleResize);
    const popup = d3.select('.popup');
    const popupOverlay = d3.select('.popup-overlay');
    
    function showPopup(data) {
      popup.select('h4').text(data.interval);
      popup.select('p').html(`
        Total Waste: <strong>${data.total}</strong><br>
        Top Countries: ${data.countries
          .sort((a, b) => b.count - a.count)
          .slice(0, 3)
          .map(c => `${c.country} (${c.count})`)
          .join(', ')}
      `);
      
      popup.style('display', 'block');
      popupOverlay.style('display', 'block');
      document.body.style.overflow = 'hidden';
    }
    
    function hidePopup() {
      popup.style('display', 'none');
      popupOverlay.style('display', 'none');
      document.body.style.overflow = 'auto';
    }
    d3.select('.close-btn').on('click', hidePopup);
    popupOverlay.on('click', hidePopup);
    function renderChart(data) {
      window.chartData = data;
      
      const size = createResponsiveSVG();
      const chartRadius = size * 0.38;
      const decorationRadius = size * 0.48;
      
      const svg = d3.select('#chart');
      svg.selectAll('*').remove();
      
      const chartGroup = svg.append('g');
      const gridLevels = 6;
      const gridCircles = Array(gridLevels).fill().map((_, i) => {
        return (i + 1) * (decorationRadius / gridLevels);
      });
      
      chartGroup.selectAll('.celestial-circle')
        .data(gridCircles)
        .enter()
        .append('circle')
        .attr('class', (d, i) => i % 3 === 0 ? 'celestial-circle' : 
                               i % 2 === 0 ? 'celestial-circle-dashed' : 'celestial-circle-dotted')
        .attr('r', d => d);
      
      const radialCount = 24;
      const radialAngles = Array(radialCount).fill().map((_, i) => {
        return (i * (2 * Math.PI / radialCount));
      });
      
      chartGroup.selectAll('.radial-line')
        .data(radialAngles)
        .enter()
        .append('line')
        .attr('class', 'radial-line')
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', angle => Math.cos(angle) * decorationRadius)
        .attr('y2', angle => Math.sin(angle) * decorationRadius);
      
      gridCircles.forEach(circle => {
        radialAngles.forEach(angle => {
          chartGroup.append('circle')
            .attr('class', 'grid-dot')
            .attr('cx', Math.cos(angle) * circle)
            .attr('cy', Math.sin(angle) * circle)
            .attr('r', 0.7);
        });
      });
      const celestialBodies = [];
      const numBodies = 6;
      
      for (let i = 0; i < numBodies; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * decorationRadius * 0.4 + decorationRadius * 0.8;
        const size = Math.random() * 5 + 3;
        
        celestialBodies.push({
          x: Math.cos(angle) * distance,
          y: Math.sin(angle) * distance,
          size
        });
      }
      
      celestialBodies.forEach(body => {
        chartGroup.append('circle')
          .attr('class', 'celestial-body-glow')
          .attr('cx', body.x)
          .attr('cy', body.y)
          .attr('r', body.size * 2);
      });
      
      chartGroup.selectAll('.celestial-body')
        .data(celestialBodies)
        .enter()
        .append('circle')
        .attr('class', 'celestial-body')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => d.size);
      
      for (let i = 0; i < celestialBodies.length - 1; i++) {
        const shouldConnect = Math.random() > 0.3;
        if (shouldConnect) {
          chartGroup.append('line')
            .attr('class', 'constellation-line')
            .attr('x1', celestialBodies[i].x)
            .attr('y1', celestialBodies[i].y)
            .attr('x2', celestialBodies[i + 1].x)
            .attr('y2', celestialBodies[i + 1].y);
        }
      }
      chartGroup.append('text')
        .attr('class', 'title')
        .attr('y', -chartRadius - 40)
        .text('SPACE DEBRIS BY TIME INTERVAL');
      
      chartGroup.append('text')
        .attr('class', 'subtitle')
        .attr('y', -chartRadius - 20)
        .text('ORBITAL DEBRIS TRACKING • 1960-2024');
      const angleScale = d3.scaleBand()
        .domain(data.map(d => d.interval))
        .range([0, 2 * Math.PI])
        .padding(0.04);
      const maxTotal = d3.max(data, d => d.total);
      const rScale = d3.scaleSqrt()
        .domain([0, maxTotal])
        .range([0, chartRadius]);
      const intervalColor = d3.scaleSequential()
        .domain([
          d3.min(data, d => parseInt(d.interval.split('-')[0])),
          d3.max(data, d => parseInt(d.interval.split('-')[1]))
        ])
        .interpolator(d3.interpolate("rgba(69, 123, 157, 0.7)", "rgba(255, 255, 255, 0.8)"));
      const intervalArc = d3.arc()
        .innerRadius(0)
        .outerRadius(d => rScale(d.total))
        .startAngle(d => angleScale(d.interval))
        .endAngle(d => angleScale(d.interval) + angleScale.bandwidth());
      
      chartGroup.selectAll('.interval-segment')
        .data(data)
        .enter()
        .append('path')
        .attr('class', 'interval-segment')
        .attr('d', intervalArc)
        .attr('fill', d => intervalColor(parseInt(d.interval.split('-')[0])))
        .attr('fill-opacity', 0.5)
        .on('click', function(event, d) {
          d3.select(this)
            .attr('fill-opacity', 0.7);
          showPopup(d);
        });
      const labelData = data.map(d => {
        const angle = angleScale(d.interval) + angleScale.bandwidth() / 2;
        const r = rScale(d.total) + chartRadius * 0.22; 
        const x = r * Math.cos(angle - Math.PI / 2);
        const y = r * Math.sin(angle - Math.PI / 2);
        
        return {
          interval: d.interval,
          total: d.total,
          angle,
          baseX: r * Math.cos(angle - Math.PI / 2),
          baseY: r * Math.sin(angle - Math.PI / 2),
          x,
          y
        };
      });
      chartGroup.selectAll('.label-connector')
        .data(labelData)
        .enter()
        .append('line')
        .attr('class', 'label-connector')
        .attr('x1', d => {
          const angle = d.angle - Math.PI / 2;
          return rScale(d.total) * Math.cos(angle);
        })
        .attr('y1', d => {
          const angle = d.angle - Math.PI / 2;
          return rScale(d.total) * Math.sin(angle);
        })
        .attr('x2', d => d.x)
        .attr('y2', d => d.y);
      chartGroup.selectAll('.interval-label')
        .data(labelData)
        .enter()
        .append('text')
        .attr('class', 'label')
        .attr('transform', d => {
          const angle = d.angle - Math.PI / 2;
          const distance = rScale(d.total) + chartRadius * 0.2;
          const x = distance * Math.cos(angle);
          const y = distance * Math.sin(angle);
          
          if (angle > 0 && angle < Math.PI) {
            return `translate(${x}, ${y}) rotate(${(angle * 180 / Math.PI) + 180})`;
          } else {
            return `translate(${x}, ${y}) rotate(${angle * 180 / Math.PI})`;
          }
        })
        .attr('dy', '0.35em')
        .attr('text-anchor', 'middle')
        .text(d => `${d.interval}`)
        .style('opacity', 1);
    }
    function updateStarryBackground() {
      const starsSvg = d3.select(".starry-background");
      if (starsSvg.empty()) return;
      const viewWidth = window.innerWidth;
      const viewHeight = window.innerHeight;
      starsSvg.selectAll("*").remove();
      starsSvg
        .attr("width", viewWidth)
        .attr("height", viewHeight)
        .attr("viewBox", `0 0 ${viewWidth} ${viewHeight}`);
      const starCount = Math.max(50, Math.floor((viewWidth * viewHeight) / 1500));
      const stars = [];
      const gridSize = Math.ceil(Math.sqrt(starCount));
      const cellWidth = viewWidth / gridSize;
      const cellHeight = viewHeight / gridSize;
      
      for (let i = 0; i < starCount; i++) {
        const gridX = i % gridSize;
        const gridY = Math.floor(i / gridSize);
        const x = gridX * cellWidth + Math.random() * cellWidth;
        const y = gridY * cellHeight + Math.random() * cellHeight;
        stars.push({ x, y });
      }
      starsSvg
        .selectAll(".star")
        .data(stars)
        .enter()
        .append("circle")
        .attr("class", "star")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", () => Math.random() * 1.5 + 0.2)
        .attr("opacity", () => Math.random() * 0.5 + 0.3);
    }
    updateStarryBackground();
    d3.csv("space_decay.csv")
      .then(rawData => {
        const debrisData = rawData
          .filter(d => d.OBJECT_TYPE === "DEBRIS")
          .reduce((acc, d) => {
            const launchDate = d.LAUNCH_DATE;
            if (!launchDate) return acc;

            const year = new Date(launchDate).getFullYear();
            if (isNaN(year)) return acc;

            const intervalStart = Math.floor(year / 5) * 5;
            const intervalEnd = intervalStart + 4;
            const interval = `${intervalStart}-${intervalEnd}`;

            const country = d.COUNTRY_CODE || "Unknown";

            if (!acc[interval]) {
              acc[interval] = { total: 0, countries: {} };
            }
            acc[interval].total = (acc[interval].total || 0) + 1;
            acc[interval].countries[country] = (acc[interval].countries[country] || 0) + 1;

            return acc;
          }, {});

        const chartData = Object.entries(debrisData)
          .map(([interval, info]) => ({
            interval,
            total: info.total,
            countries: Object.entries(info.countries).map(([country, count]) => ({ country, count }))
          }))
          .sort((a, b) => parseInt(a.interval.split('-')[0]) - parseInt(b.interval.split('-')[0]));

        if (chartData.length > 0) {
          renderChart(chartData);
        }
      })
      .catch(error => {
        console.error("Error loading the CSV file:", error);
      });
  </script>
</body>
</html>